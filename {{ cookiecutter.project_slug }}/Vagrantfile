# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|

  if Vagrant::Util::Platform.windows? then
    def running_as_admin
      # query the LOCAL SERVICE account reg key (requires admin privileges)
      system('reg query "HKU\S-1-5-19"', :out => File::NULL)
    end

    unless running_as_admin
      puts "Admin rights are required to create symlinks. Try running this Vagrantfile again from an admin command prompt."
      exit 1
    end
  end

  config.vagrant.plugins = [
    "vagrant-vbguest",
    "vagrant-hostmanager",
  ]
  config.vm.box = "centos/7"
  config.vm.box_check_update = true
  # disable the default vagrant mount. We configure custom mounts on the VM separately.
  config.vm.synced_folder ".", "/vagrant", disabled: true
  config.vbguest.auto_update = true
  config.hostmanager.enabled = true
  config.hostmanager.manage_host = true
  config.hostmanager.manage_guest = true

  config.vm.define "dev", primary: true do |machine|
    machine.vm.hostname = "{{ cookiecutter.dev_vm_hostname }}"
    machine.hostmanager.aliases = ["api.{{ cookiecutter.dev_vm_hostname }}",]
    machine.vm.synced_folder(
      "./backend_app",
      "/opt/{{ cookiecutter.project_slug }}_backend/current",
      type: "virtualbox",
      mount_options: ["uid=1234", "gid=1234"]
    )
    machine.vm.network "private_network", ip: "172.17.177.21"
    machine.vm.provider "virtualbox" do |virtualbox|
      virtualbox.name = "{{ cookiecutter.project_slug }}_dev"
      virtualbox.memory = 1024
    end
  end

  config.vm.define "db" do |machine|
    machine.vm.hostname = "{{ cookiecutter.db_vm_hostname }}"
    machine.vm.network "private_network", ip: "172.17.177.22"
    machine.vm.provider "virtualbox" do |virtualbox|
      virtualbox.name = "{{ cookiecutter.project_slug }}_db"
      virtualbox.memory = 512
    end
  end

  # We spin up another VM and execute ansible using the ansible_local vagrant
  # provisioner, as opposed to executing ansible directly from the host
  # machine.
  #
  # This helps simplify the initial setup process, creates a
  # consistent provisioning environment and allows us to provision a
  # dev environment on host machines where Ansible is not supported,
  # such as Windows.
  # (see https://docs.ansible.com/ansible/latest/user_guide/windows_faq.html#can-ansible-run-on-windows )
  #
  # However, this process does result in the creation of a 'controller' VM,
  # which increases the system resources used for this dev environment.
  config.vm.define "controller" do |machine|
    machine.vm.network "private_network", ip: "172.17.177.20"
    machine.vm.synced_folder "./provisioning", "/provisioning", type: "virtualbox"
    machine.vm.synced_folder "./.vagrant/machines", "/vagrant_machines", type: "virtualbox"

    machine.vm.provider "virtualbox" do |virtualbox|
      virtualbox.name = "{{ cookiecutter.project_slug }}_controller"
      virtualbox.memory = 256
    end
    machine.vm.provision "ansible_local" do |ansible|
      ansible.compatibility_mode = "2.0"
      ansible.playbook = "playbook.yml"
      ansible.provisioning_path = "/provisioning"
      ansible.config_file = "ansible-vagrant.cfg"
      ansible.install_mode = "pip_args_only"
      ansible.pip_install_cmd = "sudo yum install -y epel-release && sudo yum install -y python2-pip"
      ansible.pip_args = "-r /provisioning/requirements.txt"
      ansible.galaxy_role_file = "requirements.yml"
      ansible.galaxy_command = "ansible-galaxy install --role-file=%{role_file} --force"
      ansible.verbose = false
      ansible.limit = "all"
      ansible.inventory_path = "environments/dev/inventory.yml"
    end
    # Shut down the controller VM once it has finished provisioning the other VMs.
    # machine.vm.provision "shell", inline: "shutdown -h now"
  end

end
